Client-driven integration

Чтобы продемонстрировать, почему интеграция, управляемая клиентом, проста, давайте обратимся
к нашей надежной пиццерии и ее API для заказа пиццы. Допустим, мы выпускаем приложение
для смартфона, использующее API. В этом сценарии API пиццерии является сервером, а приложение
для смартфона - клиентом. Клиент использует приложение, чтобы выбрать пиццу, а затем 
нажимает кнопку, чтобы разместить заказ. Как только кнопка нажата, приложение знает,
что ему нужно сделать запрос к API пиццерии.

В более общем смысле, когда человек взаимодействует с клиентом, клиент точно знает, когда
данные изменяются, поэтому он может немедленно вызвать API, чтобы сообщить серверу. Нет
никакой задержки (следовательно, происходит в реальном времени), и процесс эффекитвен,
потому что для каждого действия, предпринимаемого человеком, делается только один запрос.

Интеграция, управляемая сервером

После размещения заказа на пиццу покупатель может захотеть узнать, когда пицца будет готова.
Как мы используем API, чтобы предоставлять им обновления? Что ж, это немного сложнее.
Покупатель не имеет отношения к приготовлению пиццы. Он ждет, пока пиццерия приготовит пиццу и обновит
статус заказа. Другими словами, данные на сервере меняются, и клиент должен знать об этом.
Тем не менее, если сервер не может делать запросы, мы, кажется, застряли!

Для решения этого типа проблемы мы используем вторую категорию интеграций. Есть ряд решений,
которые разработчики программного обеспечения используют, чтобы обойти ограничение, что только 
клиентыы могут отправлять запросы. Давайте посмотри на каждое из таких решений.

В 
